import Data.Maybe

{-
FUNX
-}

-- bgold's
let maybeInd xs i | i < length xs = Just $ xs!!i
                  | otherwise = Nothing
    chordate cs m n = map (+m) $ cs!!n
    unMaybe = (fromJust <$>) . filterValues isJust
    flatpat p = stack [unMaybe $ fmap (`maybeInd` i) p | i <- [0..9]]
    enchord chords pn pc = flatpat $ (chordate chords) <$> pn <*> pc
--  $ n (slowcat $ map (flip toScale $ "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]") [minor, kumai, hirajoshi, iwato])
--  $ n (toScale major "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]/4")
    toScale::[Int] -> Pattern Int -> Pattern Int
    toScale s p = (+) <$> fmap (s!!) notep <*> fmap (12*) octp
      where notep = fmap (`mod` (length s)) p
            octp  = fmap (`div` (length s)) p
    somecyclesBy x = when (test x) -- cycle-by-cycle version of sometimesBy
      where test x c = (timeToRand $ fromIntegral c) < x
    -- a new random number each cycle, looping after n cycles
    cyclerand n = Pattern $ \(s,e) -> [((s,e),(s,e),timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    cycleirand m n = Pattern $ \(s,e) -> [((s,e),(s,e), floor $ (*m) $ timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]

-- anny's
let bpm b = cps (b/60)
    tmod s e = (# nudge (scale 0 s $ fmap (**e) saw1))
    tmod' s e = tmod (s*(1/(105/60))) e
    mt s d i = slow s $ tmod' 0.5 3 $ density d $ i

-- danielmkarlson's
let runnow d p = do now <- getNow
                    d $ (nextSam now) ~> p


-- based on slowspread :-)
let randspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
    randspread f xs p = randcat $ map (\x -> f x p) xs


{-
SynthDef params
-}

let (amp, _) = pF "amp" (Just 0)
    (ctf, _) = pF "ctf" (Just 0)
    (detune, _) = pF "detune" (Just 0)
    (lpcutoff, _) = pF "lpcutoff" (Just 0)
    (lforate, _) = pF "lforate" (Just 0)
    (lfowidth, _) = pF "lfowidth" (Just 0)
    (lfo, _) = pF "lfo" (Just 0)
    (numharm, _) = pF "numharm" (Just 0)
    (ratio, _) = pF "ratio" (Just 0)
    (rq, rq_p) = pF "rq" (Just 0)
    (sinfreq, _) = pF "sinfreq" (Just 0)

{-
SynthDef generic params.
-}

let mf x = fst $ pF x (Just 0)
    mi x = fst $ pI x (Just 0)
