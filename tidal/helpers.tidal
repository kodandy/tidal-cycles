-- import Data.Maybe
-- import Sound.Tidal.Utils

let mute = const silence
    -- bgold's
    maybeInd xs i | i < length xs = Just $ xs!!i
                  | otherwise = Nothing
    chordate cs m n = map (+m) $ cs!!n
    unMaybe = (fromJust <$>) . filterValues isJust
    flatpat p = stack [unMaybe $ fmap (`maybeInd` i) p | i <- [0..9]]
    enchord chords pn pc = flatpat $ (chordate chords) <$> pn <*> pc
--  $ n (slowcat $ map (flip toScale $ "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]") [minor, kumai, hirajoshi, iwato])
--  $ n (toScale major "[0 1 2 3  4 3 2 1  0 -1 0 -1  0 ~ ~ ~]/4")
    toScale::[Int] -> Pattern Int -> Pattern Int
    toScale s p = (+) <$> fmap (s!!) notep <*> fmap (12*) octp
      where notep = fmap (`mod` (length s)) p
            octp  = fmap (`div` (length s)) p
    somecyclesBy x = when (test x) -- cycle-by-cycle version of sometimesBy
      where test x c = (timeToRand $ fromIntegral c) < x
    -- a new random number each cycle, looping after n cycles
    cyclerand n = Pattern $ \(s,e) -> [((s,e),(s,e),timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    cycleirand m n = Pattern $ \(s,e) -> [((s,e),(s,e), floor $ (*m) $ timeToRand $ fromIntegral $ (floor $ sam s) `mod` n)]
    -- anny's
    bpm b = cps (b/60)
    tmod s e = (# nudge (scale 0 s $ fmap (**e) saw1))
    tmod' s e = tmod (s*(1/(105/60))) e
    mt s d i = slow s $ tmod' 0.5 3 $ density d $ i
    -- danielmkarlson's
    runnow d p = do now <- getNow
                    d $ (nextSam now) ~> p
    oneshot d p = runnow d $ seqP [(0, 1, p)]
    -- based on slowspread :-)
    randspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
    randspread f xs p = randcat $ map (\x -> f x p) xs
    -- yaxu's
    loopFirst p = splitQueries $ Pattern f
      where f a@(s,e) = mapSnds' plus $ mapFsts' plus $ arc p (minus a)
              where minus = mapArc (subtract (sam s))
                    plus = mapArc (+ (sam s))
    outside n = inside (1/n)
    timeLoop n = outside n loopFirst
    seqPLoop ps = timeLoop (maximum $ map (\(_,x,_) -> x) ps) $ seqP ps
    --SynthDef generic params.
    mf x = fst $ pF x (Just 0)
    mi x = fst $ pI x (Just 0)
    -- SynthDef params
    adsr = grp [attack_p, decay_p, sustain_p, release_p]
    amp = mf "amp"
    ctf = mf "ctf"
    carp = mf "carPartial"
    detune = mf "detune"
    fmod = mf "fmod"
    freq = mf "freq"
    hctf = mf "hctf"
    idx = mf "index"
    lctf = mf "lctf"
    lforate = mf "lforate"
    lfo = mf "lfo"
    modp = mf "modPartial"
    mul = mf "mul"
    numharm = mf "numharm"
    ratio = mf "ratio"
    rq = mf "rq"
    sinfreq = mf "sinfreq"
    slidefrom = mf "slidefrom"

